
# To ≈°e razmisl kakao bo≈° naredu... Nisem zdovoljen z obliko funckcih (input/output parameteri)..
module SFF
    using CurveFit
    using ITensors
    using LaTeXStrings
    using LinearAlgebra
    using Polynomials
    # using PyPlot
    using SparseArrays
    using Statistics;


    include("../../../Helpers/FermionAlgebra.jl");
    using .FermionAlgebra;

    include("../../../Hamiltonians/H2.jl");
    using .H2;

    include("../../../Hamiltonians/H4.jl");
    using .H4;



    """
    Analitical value for spectral form factor (SSF) for GOE ansemble (for œÑ<1).
    """
    Kgoe(œÑ) = œÑ<=1 ? 2*œÑ - œÑ*log(1 + 2*œÑ) : 2 - œÑ*log((2*œÑ + 1)/(2*œÑ - 1));



    """
    Returns a Gaussian filter function exp(-(Œµ·µ¢-ŒµÃÑ)¬≤/2(Œ∑Œì)¬≤).
        
    # Arguments
    - `Œµ·µ¢::Float64`         : Set of UNFOLDED eigevalues.
    - `ŒµÃÑ::Float64`          : Unfolded energy averaged over whole spectrume at a given realization.
    - `Œì::Float64`          : Variance averaged at a given realization.
    - `Œ∑::Float64`          : Dimensionless parameter that controls the effective fraction of eigenstates included in the calculations of `K(œÑ)`.
    """
    œÅÃÇ(Œµ·µ¢::Float64, ŒµÃÑ::Float64, Œì::Float64, Œ∑::Float64)::Float64 = exp(-(Œµ·µ¢-ŒµÃÑ)^2 / (2*(Œ∑*Œì)^2));


    """
    Heviside `ùõ©(x)` function. Returns 0 for `x`<0 and 1 for `x`‚â•0.
        
    # Arguments
    - `x::Real`: Value of Heviside `ùõ©(x)` function at `x`.

    # Examples
    ```jldoctest
    julia-repl
    julia>  ùõ©(-1)
    0

    julia>  ùõ©(0)
    1
            
    julia>  ùõ©(1000)
    1
    ```
    """
    ùõ©(x:: Real):: Float64 = x<0 ? 0. : 1.;



    """
    Commulative spectral function ‚àë·µ¢ ùõ©(E - E·µ¢).

    # Arguments
    - `E::Float64`
    - `E‚Ä≤s::Vector{Float64}`: Energy spectrume to unfold.
    """
    GÃÇ(E::Real, E‚Ä≤s::Vector{Float64})::Float64 = sum( ùõ©.(E.-E‚Ä≤s) );


    """
    Checking validation of fitting parameters, so that poynomial is increasing at all values of the spectrume.

    # Arguments
    - `coeff‚Ä≤s::Vector{Float64}`: coeffitents to validate.
    - `E‚Ä≤s::Vector{Float64}`: Energy spectrume to unfold.
    """
    function ValidationOfPolynomialCoeffitions(coeff‚Ä≤s::Vector{Float64}, E‚Ä≤s::Vector{Float64})
        yÃÇ = Polynomial(coeff‚Ä≤s);
        y = yÃÇ.(E‚Ä≤s);

        Œ¥ = y[2:end] .- y[1:end-1];
        errors = filter(x -> x < 0, Œ¥);

        # if length(errors)>0
        #     println("ERROR")
        #     # throw(error("Fitting polynomial of order $(length(coeff‚Ä≤s)-1) has decrising parts in the spectrume regime."))
        # else
        #     println("Polynomial with coeffitents $(coeff‚Ä≤s), is all increasing in the range of $(round(E‚Ä≤s[1], digits=3)) to $(round(E‚Ä≤s[end], digits=3))")
        # end
    end


    """
    Compute polynomial coeffitents for unfolding process.

    # Arguments
    - `E‚Ä≤s::Vector{Float64}`: Energy spectrume to unfold.
    - `n::Int64 = 5: Degree of polynomial to fit.`
    """
    function gÃÑ‚Çô_coeffs(E‚Ä≤s::Vector{Float64}, n:: Int64 = 5):: Vector{Float64}
        y = map(x -> GÃÇ(x,E‚Ä≤s), E‚Ä≤s);
        coeff‚Ä≤s = poly_fit(E‚Ä≤s, y, n);

        ValidationOfPolynomialCoeffitions(coeff‚Ä≤s, E‚Ä≤s);
        
        return coeff‚Ä≤s;
    end


    """
    Function returns fitting polynomial coeffitents on unfolded spectrum, and energy spectrum. 

    # Arguments
    - `numberOfIterations:: Int64`: Number of iterations for averaging.
    - `L::Int64 = 5: system size.`
    - `q::Int64: Value of disorder parameter in SYK model.`
    - `n::Int64: Degree of polynomial to fit.`
    """
    function KÃÇ_data(numberOfIterations:: Int64, L:: Int64, q:: Real, n:: Int64 = 5)
        coeff‚Ä≤s = Vector{Any}();
        Es‚Ä≤s = Vector{Any}();


        for i in 1:numberOfIterations
            # println(i)
            params2 = H2.Params(L);
            H‚ÇÇ = H2.HÃÇ(params2);
            params4 = H4.Params(L);
            H‚ÇÑ = H4.HÃÇ(params4);

            H = H‚ÇÇ .+ q .* H‚ÇÑ;
            Es = eigvals(Symmetric(Matrix(H))) 

            coeffs = gÃÑ‚Çô_coeffs(Es, n);

            push!(coeff‚Ä≤s, coeffs);
            push!(Es‚Ä≤s, Es); 
        end

        return coeff‚Ä≤s, Es‚Ä≤s;
    end




    # """
    # Function returns value of Spectral Form Factor at value œÑ and for coeffitents annd spectrum obtained from KÃÇ_data.

    # # Arguments
    # - `numberOfIterations:: Int64`: Number of iterations for averaging.
    # - `L::Int64 = 5: system size.`
    # - `q::Int64: Value of disorder parameter in SYK model.`
    # - `n::Int64: Degree of polynomial to fit.`
    # """
    # function KÃÇ(œÑ::Float64, coeff‚Ä≤s:: Vector{Any}, E‚Ä≤s:: Vector{Any}, Œ∑:: Float64)
    #     numberOfIterations:: Int = length(coeff‚Ä≤s);

    #     KÃÉ:: Float64 = 0.; 
    #     Z:: Float64 = 0.;

    #     for i in 1:numberOfIterations
    #         coeffs = coeff‚Ä≤s[i];
    #         Es = E‚Ä≤s[i];
    #         # println(coeffs)

    #         gÃÑ‚Çô = Polynomial(coeffs);

    #         Œµ‚Ä≤s = gÃÑ‚Çô.(Es);    
    #         ŒµÃÑ = mean(Œµ‚Ä≤s);    
    #         Œì = stdm(Œµ‚Ä≤s, ŒµÃÑ); 

    #         # plot(Es, Œµ‚Ä≤s)


    #         KÃÉ·µ¢ = sum(map(Œµ·µ¢ -> œÅÃÇ(Œµ·µ¢, ŒµÃÑ, Œì, Œ∑)*exp(-2*œÄ*Œµ·µ¢*œÑ*1im), Œµ‚Ä≤s));   KÃÉ += abs(KÃÉ·µ¢)^2 / numberOfIterations;
    #         Z·µ¢ = sum( abs.(œÅÃÇ.(Œµ‚Ä≤s, ŒµÃÑ, Œì, Œ∑)).^2);   Z += Z·µ¢ / numberOfIterations;
    #     end

    #     # plt.show()

    #     K = KÃÉ/Z;
    #     return K;
    # end



    """
    Function returns value of Spectral Form Factor at value œÑ and for coeffitents annd spectrum obtained from KÃÇ_data.

    # Arguments
    - `numberOfIterations:: Int64`: Number of iterations for averaging.
    - `L::Int64 = 5: system size.`
    - `q::Int64: Value of disorder parameter in SYK model.`
    - `n::Float64: Degree of polynomial to fit.`
    """
    function KÃÇ(œÑ‚Ä≤s::Vector{Float64}, coeff‚Ä≤s:: Vector{Vector{Float64}}, E‚Ä≤s:: Vector{Vector{Float64}}, Œ∑:: Float64)
        numberOfIterations:: Int = length(coeff‚Ä≤s);
        NœÑ:: Int64 = length(œÑ‚Ä≤s);

        KÃÉ:: Vector{Float64} = zeros(Float64, NœÑ); 
        Z:: Vector{Float64} = zeros(Float64, NœÑ); 

        for i in 1:numberOfIterations
            coeffs = coeff‚Ä≤s[i];
            Es = E‚Ä≤s[i];

            gÃÑ‚Çô = Polynomial(coeffs);

            Œµ‚Ä≤s = gÃÑ‚Çô.(Es);    
            ŒµÃÑ = mean(Œµ‚Ä≤s);    
            Œì = stdm(Œµ‚Ä≤s, ŒµÃÑ); 
            
            if Œ∑==Inf
                println(Œ∑, "  ", i );
                for (j, œÑ) in enumerate(œÑ‚Ä≤s)
                    KÃÉ·µ¢ = sum(map(Œµ·µ¢ -> exp(-2*œÄ*Œµ·µ¢*œÑ*1im), Œµ‚Ä≤s));   KÃÉ[j] += abs(KÃÉ·µ¢)^2 / numberOfIterations;
                end
            else
                for (j, œÑ) in enumerate(œÑ‚Ä≤s)
                    KÃÉ·µ¢ = sum(map(Œµ·µ¢ -> œÅÃÇ(Œµ·µ¢, ŒµÃÑ, Œì, Œ∑)*exp(-2*œÄ*Œµ·µ¢*œÑ*1im), Œµ‚Ä≤s));   KÃÉ[j] += abs(KÃÉ·µ¢)^2 / numberOfIterations;
                    Z·µ¢ = sum( abs.(œÅÃÇ.(Œµ‚Ä≤s, ŒµÃÑ, Œì, Œ∑)).^2);   Z[j] += Z·µ¢ / numberOfIterations;
                end
            end
        end

        Ks = Œ∑==Inf ? KÃÉ : KÃÉ./Z
        return Ks;
    end


    """
    Function returns value of Spectral Form Factor at value œÑ and for coeffitents annd spectrum obtained from KÃÇ_data.

    # Arguments
    - `numberOfIterations:: Int64`: Number of iterations for averaging.
    - `L::Int64 = 5: system size.`
    - `q::Int64: Value of disorder parameter in SYK model.`
    - `n::Float64: Degree of polynomial to fit.`
    """
    function KÃÇc(œÑ‚Ä≤s::Vector{Float64}, coeff‚Ä≤s:: Vector{Vector{Float64}}, E‚Ä≤s:: Vector{Vector{Float64}}, Œ∑:: Float64)
        numberOfIterations:: Int = length(coeff‚Ä≤s);
        NœÑ:: Int64 = length(œÑ‚Ä≤s);

        K1:: Vector{Float64} = zeros(Float64, NœÑ); 
        KÃÑ2:: Vector{Complex} = zeros(Complex, NœÑ); 
        A:: Float64 = 0.;
        BÃÑ:: Complex = 0.;
        Z:: Float64 = 0.;

        for i in 1:numberOfIterations
            coeffs = coeff‚Ä≤s[i];
            Es = E‚Ä≤s[i];
            if Œ∑==Inf
                println("TO ≈°e naredi oziroma popravi!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" );
                throw(error("ni ≈°e implementirano!"));
            else
                K1_, KÃÑ2_, A_, BÃÑ_, Z_ = KÃÇ_singleIteration(Es, coeffs, œÑ‚Ä≤s, Œ∑);

                K1 .+= K1_ ./ numberOfIterations;
                KÃÑ2 .+= KÃÑ2_ ./ numberOfIterations;
                A  += A_  / numberOfIterations;
                BÃÑ  += BÃÑ_  / numberOfIterations;
                Z  += Z_  / numberOfIterations;
            end
        end

        K2:: Vector{Float64} = @. abs(KÃÑ2)^2;
        B:: Float64 = abs(BÃÑ)^2;

        K:: Vector{Float64}  = @.  K1  / Z;
        Kc:: Vector{Float64} = @. (K1 - A*K2/B) / Z;
        return K, Kc;
    end



    function KÃÇ_singleIteration(E‚Ä≤s::Vector{Float64}, coeffs::Vector{Float64}, œÑ‚Ä≤s::Vector{Float64}, Œ∑:: Float64)
        gÃÑ‚Çô = Polynomial(coeffs);

        Œµ‚Ä≤s = gÃÑ‚Çô.(E‚Ä≤s);    
        ŒµÃÑ = mean(Œµ‚Ä≤s);    
        Œì = std(Œµ‚Ä≤s); 

        K1·µ¢(œÑ) = abs(sum( map(Œµ·µ¢ ->     œÅÃÇ(Œµ·µ¢, ŒµÃÑ, Œì, Œ∑)*exp(-2*œÄ*Œµ·µ¢*œÑ*1im), Œµ‚Ä≤s)))^2
        KÃÑ2·µ¢(œÑ) =     sum( map(Œµ·µ¢ ->     œÅÃÇ(Œµ·µ¢, ŒµÃÑ, Œì, Œ∑)*exp(-2*œÄ*Œµ·µ¢*œÑ*1im), Œµ‚Ä≤s))
        A·µ¢     = abs(sum( map(Œµ·µ¢ ->     œÅÃÇ(Œµ·µ¢, ŒµÃÑ, Œì, Œ∑)                   , Œµ‚Ä≤s)))^2;
        BÃÑ·µ¢     =     sum( map(Œµ·µ¢ ->     œÅÃÇ(Œµ·µ¢, ŒµÃÑ, Œì, Œ∑)                   , Œµ‚Ä≤s));
        Z·µ¢     =     sum( map(Œµ·µ¢ -> abs(œÅÃÇ(Œµ·µ¢, ŒµÃÑ, Œì, Œ∑))^2                , Œµ‚Ä≤s));

        if Œ∑==Inf
            println("To ≈°e naredi oziroma popravi!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" );
            throw(error("ni ≈°e implementirano!"));
        else
            return K1·µ¢.(œÑ‚Ä≤s), KÃÑ2·µ¢.(œÑ‚Ä≤s), A·µ¢, BÃÑ·µ¢, Z·µ¢
        end
    end




    """
    Thouless time (in unphysical units).

    # Arguments
    - `K:: Vector{Float64}`: Vectro of Spectral Form Factor for different values of œÑ.
    - `œÑ:: Vector{Float64}`: Vector of œÑ‚Ä≤s.`
    """
    function œÑÃÇ_Th0(K::Vector{Float64}, œÑ::Vector{Float64}, Œî::Int64=100, Œµ::Float64=0.08)        
        KÃÑ = Vector{Float64}();
        œÑ‚Ä≤s = œÑ[Œî:end-Œî]
        for i in Œî:length(œÑ)-Œî
            append!(KÃÑ, mean(K[i-Œî+1:i+Œî-1]) )
        end

        ŒîK‚Ä≤s = abs.(  log10.(KÃÑ ./ Kgoe.(œÑ‚Ä≤s))  );

        # WE make linear regresion to determine œÑ_th more pricisely, k is a slope and n dispacement of a linear function 
        i = findall(x -> x<Œµ, ŒîK‚Ä≤s)[1]

        i1 = i-1;
        i2 = i;

        k = (ŒîK‚Ä≤s[i1] - ŒîK‚Ä≤s[i2])/(œÑ‚Ä≤s[i1] - œÑ‚Ä≤s[i2]);
        n = ŒîK‚Ä≤s[i1] - k*œÑ‚Ä≤s[i1];

        œÑ_th = (Œµ - n)/k;
        return œÑ_th;
    end



    """
    Thouless time  (in unphysical units).

    # Arguments
    - `K:: Vector{Float64}`: Vectro of Spectral Form Factor for different values of œÑ.
    - `ŒîœÑ:: Float64`: Steps of œÑ in which to search for Thoulless time.`
    """
    function œÑÃÇ_Th(NœÑ::Int64, coeffs‚Ä≤s:: Vector{Vector{Float64}}, Es‚Ä≤s:: Vector{Vector{Float64}}, Œ∑:: Float64)        
        min = -4;
        max = 0;

        K‚Ä≤s = Vector{Float64}();
        œÑ‚Ä≤s = Vector{Float64}();
        Kc‚Ä≤s = Vector{Float64}();
        œÑc‚Ä≤s = Vector{Float64}();
        œÑ_Th = 0.;
        œÑ_Th_c = 0.;


        isœÑCalculated = false
        while !isœÑCalculated 
            N = Int((max-min)*NœÑ√∑1);
            x = LinRange(min, max, N);
            œÑs = 10 .^x;


            Ks, Kcs= KÃÇc(œÑs, coeffs‚Ä≤s, Es‚Ä≤s, Œ∑);

            append!(œÑ‚Ä≤s, œÑs);
            append!(K‚Ä≤s, Ks);

            append!(œÑc‚Ä≤s, œÑs);
            append!(Kc‚Ä≤s, Kcs);

            try
                œÑ_Th = œÑÃÇ_Th0(Ks, œÑs);
                œÑ_Th_c = œÑÃÇ_Th0(Kcs, œÑs);
                isœÑCalculated = true;
            catch error
                if isa(error, BoundsError)
                    println("error: ", error);
                    # println("‚ùó Nismo na≈°li œÑ_Th, nastavimo  min = ", max, ",  in max = ", max +1, "üßØ üßØ");
                    min = max;
                    max = max + 1;
                    isœÑCalculated = false;

                    if max >= 5
                        throw(error());
                    end
                else
                    println("Nekaj je ≈°lo hudo narobe üòû:")
                    println(error)
                    println(2)
                    throw(error());
                end
            end

        end

        
        return œÑ‚Ä≤s, K‚Ä≤s, œÑ_Th, Kc‚Ä≤s, œÑ_Th_c;
    end



    """
    Heisemberg time in physical units, obtained by analitical expression of Œ¥EÃÑ from t_H = 1/Œ¥E.

    # Arguments
    - `Es‚Ä≤s:: Vector{Float64}`: Vectro energy spectrums of different realizations.
    """
    function tÃÇ_H(Es‚Ä≤s)
        D = length(Es‚Ä≤s[1]);
        a1 = map(Es -> sum(Es.^2)/D  , Es‚Ä≤s);
        a2 = map(Es -> sum(Es)^2/D^2, Es‚Ä≤s);

        trH2 = mean(a1);
        tr2H = mean(a2);
        

        Œì0¬≤ = trH2 - tr2H;

        
        œá = 0.3413;
        Œ¥EÃÑ = ‚àö(Œì0¬≤) / (œá*D);
        t_H = 1/Œ¥EÃÑ

        return t_H;
    end


    """
    Thoulless time in physical units calculated from Thoulless time œÑ_Th and Heisemberg time t_H.
    """
    tÃÇ_Th(œÑ_Th, t_H) = œÑ_Th * t_H;



    """
    Indicator g calculated from Thoulless time t_Th and Heisenberg time t_H (both in physical units).
    """
    gÃÇ(t_Th:: Float64,t_H:: Float64) = log10(t_H/t_Th);



    """
    Indicator g calculated from Thoulless time œÑ_Th (in unphysical units).
    """
    gÃÇ(œÑ_Th:: Float64) = - log10(œÑ_Th);

end


